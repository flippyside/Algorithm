/*
题目描述
牌组中的每张卡牌都对应有一个唯一的整数。小蓝鲸想进行一些奇妙的操作，以想要的顺序对这套卡片进行排序。

小蓝鲸有一组未展示的卡牌，卡牌上的数字按从小到大的顺序排列。

小蓝鲸会重复执行以下步骤，直到展示所有卡牌为止：

从牌组顶部抽一张牌，展示它，然后将其从牌组中移出。

如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。

如果仍有未展示的牌，那么返回步骤 1。否则，停止行动。

小蓝鲸希望找到一个合适的顺序，使得按照上面的规则摸牌时，能以 递增 顺序展示卡牌。

答案中的第一张牌被认为处于牌堆顶部。

输入格式
第一行包含一个整数 n，表示牌组中的卡牌数量。
第二行包含 n 个整数，表示牌组中的卡牌上面的数字。

示例
Input:
7 17 13 11 7 5 3 2

Output:
2 13 3 11 5 17 7

解释：

我们得到的牌组顺序为 [2,3,5,7,11,13,17]（这个顺序不重要），然后将其重新排序。
重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。
我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。
我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。
我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。
我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。
我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。
我们展示 13，然后将 17 移到底部。牌组现在是 [17]。
我们显示 17。
由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。

从最大的数开始，显示，入队
将队首的数字移到队尾
下一个数入队

tt   hh
队尾 队首

提示：
1 <= 数据长度 <= 1024 1 <= 元素大小 <= 10^6 数据中每个元素互不重复，输入数据按升序排列。
*/


#include <iostream>
#include <cstring>
using namespace std;
typedef pair<int, int> pii;
typedef long long ll;
const int N = 1e6;

int n;
int q[N], hh = 0, tt = -1;
int stk[N], tt2 = -1;

int main(){
    cin >> n;
    int x, tmp = n;
    while(tmp--) cin >> stk[++tt2];
    while(n--){
        x = stk[tt2--];
        q[++tt] = x; // 入队
        if(n != 0) q[++tt] = q[hh++]; // 将队首的数字移到队尾
    }
    for(int i = tt; i >= hh; i--) cout << q[i] << ' ';
}

index
- 背包问题
  - 01背包
  - 完全背包
  - 多重背包
  - 分组背包

- 数位统计DP
- 状态压缩DP
- 树形DP
- 记忆化搜索



# 01背包

> 每个物品只能用一次

物品数量：N
背包容量：V
每个物品只能装入一次。
第 i 件物品的体积是vi，价值是wi
将哪些物品装入背包，可使得物品的总体积不超过背包容量，且总价值最大。输出最大价值

## 二维

- 状态表示：二维，f(i, j)：
  - 集合：
    - 只从前 i 个物品中选，总体积不超过 j 的所有选法。
    - 条件：
      - 只从前 i 个物品中选
      - 总体积 <= j
  - 属性：总价值的最大值
- 状态计算：集合的划分：把集合分成两部分1、2，把所有**不包含第 i 个**物品的选法放到 1，把所有包含第 i 个物品的选法放到 2
  - 集合1：
    - 只从第 `1 ~ i - 1` 个物品选择，总体积不超过 j 的*选法*。
    - 最大值： `f(i - 1, j)`
  - 集合2：
    - 从第 `1 ~ i - 1` 个物品选择，且包含第 i 个物品，总体积不超过 j 的*选法*。 
    - 最大值：`f(i - 1, j - v[i]) + w[i]`
        - `f(i - 1, j - v[i]) + w[i]`的推导：
            - 已知：给所有选法去掉同一个物品，它们之间的顺序不变。（所有学生的分数去掉10分，第一名还是第一名）
            - 所以把所有选法去掉第 i 个物品
            - 即为从第 `1 ~ i - 1` 个物品中选择，总体积不超过`j - vi`的选法：`f(i - 1, j - v[i])`
            - 再把第 i 个物品加回来，即为`f(i - 1, j - v[i]) + w[i]`
- 综上，`f(i, j) = max(f(i - 1, j), f(i - 1, j - v[i]) + w[i])`

答案：f(N, V)

```cpp
int f[N][N];
int v[N], w[N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for(int i = 1; i <= n; i++) // 物品数
        for(int j = 0; j <= m; j++){ // 总体积
            f[i][j] = f[i - 1][j]; // 集合1：只从前i - 1个物品中选择，总体积不超过j
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); // 集合2：从前i - 1个物品中选择，且必须选第 i 个物品，总体积不超过j
        }
    cout << f[n][m];
}
```

## 优化：一维

状态表示：一维

思路：将f[i][j]变为f[j]，只表示总体积不超过 j 的选法

```cpp
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for(int i = 1; i <= n; i++) // 物品数
        // for(int j = v[i]; j <= m; j++){ // 总体积
        for(int j = m; j >= v[i]; j--){ // 注意，j变为从后往前遍历。且if(j >= v[i])被改为循环里的 j >= v[i]
            // f[j] = f[j];
            // if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]); 
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    cout << f[m];
}
```

从前往后遍历的问题：
如果 j 从前往后遍历，那么在处理 f[j] 时，f[j - v[i]] 可能已经在当前物品的迭代中被更新了。这会导致使用了当前迭代更新过的值，产生错误结果，具体表现为可能多次考虑同一件物品，从而导致错误的最大价值计算。

```cpp
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for(int i = 1; i <= n; i++) // 物品数
        for(int j = m; j >= v[i]; j--){ // if(j >= v[i])被改为循环里的 j >= v[i]。注意，j变为从后往前遍历。
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    cout << f[m];
}
```


# 完全背包

> 每个物品能用无限次

- 状态表示：f(i, j)
  - 集合：所有只考虑前 i 个物品，且总体积不大于 j 的所有选法
  - 属性：最大值
- 状态计算：集合的划分。按照 第i个物品 在选法中的个数来划分。
    - 个数为0：f(i - 1, j)
    - 个数为k：
      - 每种选法去掉 k 个物品i
      - 求max：`f(i - 1, j - k * v[i])`
      - 将 k 个物品 i 加回来：`f(i - 1, j - k * v[i]) + k * w[i]`

```cpp
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++)
            for(int k = 0; k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
    cout << f[n][m];
}
```

## 优化：f[i][j - v]

`f[i][j] = max(f[i][j], f[i][j - v] + w)`

```
f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i])
        = max(f[i][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w, ...)
f[i - 1][j - v] = max( f[i - 1][j - v],     f[i - 1][j - 2v] + w, f[i - 1][j - 3v] + 2w...)
将i-1 => i, j - v => j
=> f[i][j] = max(f[i][j], f[i][j - v] + w)
```

```cpp
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++){
            f[i][j] = f[i - 1][j];
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }
    cout << f[n][m];
}
```

## 优化：一维

```cpp
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for(int i = 1; i <= n; i++)
        // for(int j = 0; j <= m; j++){
        for(int j = v[i]; j <= m; j++){
            // f[i][j] = f[i - 1][j];
            f[j] = f[j];
            // if(j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    cout << f[n][m];
}
```

在完全背包问题中，物品可以被多次选择，因此可以从前往后遍历容量 j。这种遍历顺序允许利用已经更新的状态，从而实现多次选择同一物品，得到正确的最大值。

```cpp
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];

    for(int i = 1; i <= n; i++)
        for(int j = v[i]; j <= m; j++) // 从小到大
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m];
}
```


# 多重背包

> 每种物品有一个数量上限si。

- 状态表示：f(i, j)
  - 集合：所有只从前 i 个物品中选，总体积不超过 j 的选法
  - 属性：最大值
- 状态计算：集合的划分。按照 第i个物品 在选法中的个数来划分。
  - 选0个：f(i - 1, j)
  - 选k个：`f(i, j) = max(f(i, j), f(i - 1, j - k * v[i]) + k * w[i])`，k <= s[i]
    - 每种选法去掉k个物品i
    - 求max：`f(i - 1, j - k * v[i])`
    - 将k个物品加回来：`f(i - 1, j - k * v[i]) + k * w[i]`

```cpp
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++)
            for(int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);

    cout << f[n][m];
}
```

关于遍历 j 的顺序究竟是从前到后or从后到前：如果用到了上一层(i-1)的状态，就从后往前。如果只用了本层(i)的状态，就正常从前往后。


## 优化

> 二进制优化：将多重背包问题转化为01背包

基本思想：如果我们有 17 个硬币，要去买 1 到 17 元钱的物品，只需将这些硬币打包成 1,2,4,8 和 2 这样的几包。前面的 4 包能保证覆盖 1 到 15 所有的情况，最后一包在之前的基础上再加上一个值，能保证实现支付的时候取整包，肯定能保证支付。
用上述的方法，就可以把 k 件相同的物品看作是 $O(\log k)$ 件物品了。

假设有一组商品，一共有11个。我们知道，十进制数字 11 可以这样表示
11=1011(B)=0111(B)+(11−0111(B))=0111(B)+0100(B)

正常背包的思路下，我们要求出含这组商品的最优解，我们要枚举12次（枚举装0，1，2....12个）。

现在，如果我们把这11个商品分别打包成含商品个数为1个，2个，4个，4个（分别对应0001,0010,0100,0100）的四个”新的商品 “, 将问题转化为01背包问题，对于每个商品，我们都只枚举一次，那么我们只需要枚举四次 ，就可以找出这含组商品的最优解。 这样就大大减少了枚举次数。


例如：
s = 1023
将第i个物品打包成`1，2, 4, 8...512`，每组最多只能选 1 次，可以通过不同组合拼凑出0~1023的所有数字。即为01背包。枚举次数：1000->10
s = 200
将第i个物品打包成`1，2, 4, 8, 16, 32, 64`，1加到64等于127，距离200还差73，故可以打包为`1，2, 4, 8, 16, 32, 64, 73`

已知s，如何寻找打包方式？
- `1, 2, 4, 8...,2^k`，这些数的总和小于 s，然后根据差值补上 c（`c = s - 和, c < 2^{k+1}`）。即为`1, 2, 4, 8...,2^k, c`

$$
O(N,V,S) = NV \log S 
$$

```cpp
const int N = 22010, M = 2010; // 每个物品最多拆分为log2000个，1000*log2000 = 1000 * 11 = 22000
int f[N];
int v[N], w[N], s[N];

int main(){
    cin >> n >> m;
    int cnt = 0;
    for(int i = 1; i <= n; i++) {
        int a,b,s;
        cin>>a>>b>>s;
        // 拆分
        int k = 1;
        while(k <= s){ // 1, 2, 4, 8...
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if(s > 0){
            cnt++;
            v[cnt] = a * s; 
            w[cnt] = b * s;
        }
    }
    n = cnt;
    
    // 01背包
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m];
}
```



# 分组背包

> 物品被分成几组，每一组只能选一个物品

- 状态表示f(i, j)
  - 集合：只从前 i 件物品中选择，且总体积不超过 j 的所有选法
  - 属性：最大值
- 状态计算：集合的划分。根据第 i 组选哪个物品来划分。
  - 第i组一个都不选：`f(i - 1, j)`
  - 第i组选了第k个物品：`f(i - 1, j - v[i, k]) + w[i, k]`

```cpp
int f[N];
int v[N][N], w[N][N], s[N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> s[i];
        for(int j = 0; j < s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= 0; j--)
            for(int k = 0; k < s[i]; k++)
                if(v[i][k] <= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
    cout << f[m];
}
```




index
- 线性DP
- 区间DP



# 线性DP

```
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

- 状态表示f(i, j)
  - 集合：所有从起点->(i, j)的路径
  - 属性：所有路径上数字之和的最大值
- 状态计算：集合划分。分为来自左上、来自右上
  - 来自左上：`f(i-1,j-1)+a(i,j)`
  - 来自右上：`f(i-1,j)+a(i,j)`
  - `max(f(i-1,j-1)+a(i,j), f(i-1,j)+a(i,j))`

```cpp
int main(){
    cin >> n;
    for(int i = 1; i <= n;i++){
        for(int j = 1; j <= i; j++){
            cin >> a[i][j];
        }
    }
    for(int i = 0; i <= n + 1; i++){
        for(int j = 0; j <= i + 1; j++){
            f[i][j] = -INF;
        }
    }
    f[1][1] = a[1][1];
    // f[i][j]: 以（i，j）为结尾的所有路径长度
    for(int i = 2; i <= n; i++){
        for(int j = 1; j <= i; j++){
            f[i][j] = max(f[i - 1][j - 1] + a[i][j], f[i - 1][j] + a[i][j]);
        }
    }
    int res = -INF;
    for(int i = 1; i <= n; i++) res = max(res, f[n][i]);
    cout << res;
}
```

##  最长上升子序列问题

```
给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。
```

子序列：由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
子数组：指的是数组中的一个连续子序列。

- 状态表示 f(i)：所有以第 i 个数结尾的上升子序列的长度的最大值
  - 集合：所有以第 i 个数结尾的上升子序列
  - 属性：长度的最大值
- 状态计算：集合的划分：倒数第 2 个数
  - 倒数第 2 个数是arr[j]，0 <= j <= i - 1。`f[i] = max(f[i], f[j] + 1), j = 0,1,...,i-1`


时间复杂度：状态数量 * 计算数量

$$
O(N) = N^2
$$

```cpp
int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin>>a[i];

    for(int i = 1; i <= n; i++){ // 选择最后一个数
        f[i] = 1; // 只有a[i]一个数
        for(int j = 1; j < i; j++) // 选择倒数第2个数，由于是序列，所以只能从 i 前面的数字中选择
            if(a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
    }

    int res = 0;
    for(int i = 1; i <= n; i++) res = max(res, f[i]);
    cout << res;
}
```

输出序列：

```cpp
代码有误
int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin>>a[i];
    for(int i = 1; i <= n; i++){ // 选择最后一个数
        f[i] = 1; // 只有a[i]一个数
        g[i] = 0;
        for(int j = 1; j < i; j++){
            if(a[j] < a[i])
                if(f[i] < f[j] + 1){ // g数组存储状态转移
                    f[i] = f[j] + 1;
                    g[i] = j;
                }
        }
    }
    int k = 1;
    for(int i = 1; i <= n; i++) if(f[k] < f[i]) k = i;
    
    cout << f[k] << endl;
    for(int i = 0; i < f[k]; i++){
        cout << a[k] << endl;
        k = g[k];
    }
}
```

## 最长公共子序列问题

```
给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。
```

- 状态表示 f(i, j)
  - 集合：所有在第一个序列的前 i 个字母出现，且在第二个序列的前 j 个字母中出现的子序列
  - 属性：长度最大值
- 划分：对于a[i]、b[i]的选择情况（1：选中  0：不选）：00、01、10、11
  - 00：f(i - 1, j - 1)
  - 01：f(i - 1, j)包含了01这种情况
  - 10：f(i, j - 1)包含了01这种情况
  - 11：f(i, j) = max(f(i, j), f(i - 1, j - 1) + 1)，即长度加1
  - 由于00情况被包含在了01、10情况中，故可以省略

```cpp
int main(){
    cin >> n >> m;
    scanf("%s%s", a + 1, b + 1);

    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            f[i][j] = max(f[i - 1][j], f[i][j - 1]); // 01、10
            if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); // 11
        }
    }
    cout << f[n][m];
}
```

# 区间DP

```
设有 N 堆石子排成一排，其编号为 1,2,3,…,N。每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。
```

- 状态表示 f(i, j)
  - 集合：所有将第 i 堆石子到第 j 堆石子合并成一堆石子的合并方式
  - 属性：代价最小值
- 状态计算：划分：将第 i 堆石子到第 j 堆的合并方式[i,j]，按照分界线的位置分成 k 类，即最后一步是将：左1右k-1、左2右k-2...左k-1右1 合并起来
  - `f(i, j) = min(f(i, k) + f(k + 1, j) + s[j] - s[i - 1])，k = i ~ j - 1`

$$
O(n^3)
$$

```cpp
int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> s[i];
    // 前缀和
    for(int i = 1; i <= n; i++) s[i] += s[i - 1];
    
    for(int len = 2; len <= n; len++) // 区间长度
        for(int i = 1; i + len - 1 <= n; i++){ // 区间左端点
            int l = i, r = i + len - 1; // 区间
            f[l][r] = INF;
            for(int k = l; k < r; k++){ // 分界线
                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[i - 1]);
            }
        }
    cout << f[1][n];
}
```

